メモリアロケータです。

これは元々 tcmalloc をベースにしていましたが、かなり分岐しています。
http://goog-perftools.sourceforge.net/doc/tcmalloc.html

メインのアロケータはページ単位で動作します。
小さなアロケーションサイズ (32kB まで) は約 70 のサイズクラスのひとつに丸められ、それぞれがちょうどそのサイズのオブジェクトの独自のフリーセットを持っています。
メモリの空きページは、1つのサイズクラスのオブジェクトのセットに分割することができ、それらは空きビットマップを使用して管理されます。

アロケータのデータ構造は以下の通りです。

fixalloc: 固定サイズのオフヒープオブジェクトのためのフリーリストアロケータで、アロケータが使用するストレージを管理するために使用されます。
mheap: malloc ヒープ、ページ (8192 バイト) 単位で管理される。
mspan: mheap で管理される使用中ページのラン。
mcentral: 与えられたサイズクラスのスパンをすべて収集する。
mcache: 空き領域のある mspan の P 単位のキャッシュ。
mstats: アロケーションの統計。

小さなオブジェクトの割り当ては、キャッシュの階層を上がっていく。

1. 1. サイズを小さいサイズクラスの一つに切り上げ、このPのmcacheの中の対応するmspanを探します。mspanの空きビットマップをスキャンして、空きスロットを探します。空きスロットがあれば、それを確保する。これはすべて、ロックを取得せずに行うことができます。

2. 2. mspanに空きスロットがない場合、必要なサイズクラスのmspanで空き領域のあるmcentralのリストから、新しいmspanを取得する。スパン全体を取得することで、mcentralをロックするコストを削減できます。

3. 3. mcentralのmspanリストが空の場合、mheapからmspanに使用するページのランを取得する。

4. 4. mheapが空であるか、十分な大きさのページランがない場合、オペレーティングシステムから新しいページグループ (少なくとも1MB) を割り当てる。大きなページランを割り当てることで、オペレーティング・システムとのやり取りにかかるコストを償却します。

mspanを掃除し、その上にあるオブジェクトを解放することは、同様の階層で進みます。

1. mspanが割り当てに応答して掃引される場合、割り当てを満たすためにmcacheに返されます。

2. 2. そうでない場合、mspanにまだ割り当てられたオブジェクトがあれば、そのmspanのサイズクラスのmcentralフリーリストに置かれます。

3. 3. それ以外の場合、mspan内のすべてのオブジェクトが解放されると、mspanのページがmheapに返され、mspanはデッドとなります。

ラージオブジェクトの割り当てと解放は、mcacheとmcentralをバイパスして、直接mheapを使用します。

mspan.needzero が false の場合、mspan のフリー・オブジェクト・スロットはすでに 0 になっています。それ以外の場合、needzero が true ならば、オブジェクトは割り当てられたときにゼロにされます。この方法でゼロ化を遅らせることには、様々な利点があります。

1. 1. スタックフレームの割り当てでは、ゼロ化を完全に避けることができます。

2. 2. プログラムがおそらくメモリに書き込もうとしているときなので、よりよい 時間的局所性を示す。

3. 3. 再使用されないページをゼロにしない。

仮想メモリのレイアウト

ヒープは64ビットでは64MB、32ビットでは4MBのアリーナの集合からなる（heapArenaBytes）。各アリーナの開始アドレスもアリーナサイズにアラインされている。

各アリーナには、そのアリーナのメタデータ（アリーナ内の全ワードのヒープビットマップとアリーナ内の全ページのスパンマップ）を格納するheapArenaオブジェクトが関連付けられています。heapArenaオブジェクト自体は、オフヒープに割り当てられます。

アリーナはアラインされているので、アドレス空間は一連のアリーナ・フレームと見なすことができます。アリーナマップ (mheap_.arenas) はアリーナフレーム番号から *heapArena に、または Go ヒープにバックアップされていないアドレス空間の部分については nil にマップします。アリーナマップは、「L1」アリーナマップと多数の「L2」アリーナマップからなる2レベルの配列として構成されていますが、アリーナは大きいので、多くのアーキテクチャでは、アリーナマップは単一の大きなL2マップから構成されています。

アリーナマップは、可能なアドレス空間全体をカバーし、Goヒープがアドレス空間の任意の部分を使用できるようにします。アロケータは、大きなスパン（したがって大きなオブジェクト）がアリーナを横断できるように、アリーナを連続させることを試みます。


仮想メモリのレイアウト

ヒープは、64ビットでは64MB、32ビットでは4MBのアリーナ（heapArenaBytes）の集合で構成されています。各アリーナの開始アドレスもアリーナサイズにアラインされています。

各アリーナには、そのアリーナのメタデータ（アリーナ内の全ワードのヒープビットマップとアリーナ内の全ページのスパンマップ）を格納するheapArenaオブジェクトが関連付けられています。heapArenaオブジェクト自体は、オフヒープに割り当てられます。

アリーナはアラインされているので、アドレス空間は一連のアリーナ・フレームと見なすことができます。アリーナ・マップ (mheap_.arenas) はアリーナ・フレーム番号から *heapArena に、または Go ヒープにバックアップされていないアドレス空間の部分には nil にマッピングします。
にマップします。アリーナマップは、「L1」アリーナマップと多数の「L2」アリーナマップからなる2レベルの配列として構成されていますが、アリーナは大きいので、多くのアーキテクチャでは、アリーナマップは単一の大きなL2マップから構成されています。

アリーナマップは、可能なアドレス空間全体をカバーし、Goヒープがアドレス空間の任意の部分を使用できるようにします。アロケータは、大きなスパン（したがって大きなオブジェクト）がアリーナを横断できるように、アリーナを連続させることを試みます。
