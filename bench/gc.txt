GOのガベージコレクション日本語

GCはミューテータースレッドと同時に実行され、型に正確であり（つまり正確）、複数の GCスレッドを並列に実行することができます。書き込みバリアを使用した同時マーク＆スイープです。これは 非世代型、非コンパクト型。アロケーションは、P毎にサイズ分離されたアロケーションを使用します。領域で、一般的なケースでのロックを排除しつつ、断片化を最小化することができます。

アルゴリズムはいくつかのステップに分解される。
これは使用されているアルゴリズムのハイレベルな説明である。GCの概要については Richard Jonesのgchandbook.orgから始めるとよいでしょう。

このアルゴリズムの知的遺産には、Dijkstraのon-the-flyアルゴリズムが含まれています。Edsger W. Dijkstra, Leslie Lamport, A. J. Martin, C. S. Scholten, and E. F. M. Steffens. 1978.
On-the-fly garbage collection: An exercise in cooperation. Commun. ACM 21, 11 (1978年11月),
966-975.
これらのステップが完全で、正しく、終了することを証明するジャーナルクオリティの証明については、以下を参照してください。Hudson, R., and Moss, J.E.B. Copying Garbage Collection without stopping the world（世界を止めずにガベージコレクションをコピーする）。
Concurrency and Computation: Practice and Experience 15(3-5), 2003.

1. GC はスイープ終了を実行します。

   a. 世界を停止させる。これにより、すべてのPsはGC安全点に到達する。

   b. 掃引されていないスパンを掃引します。このGCサイクルが予想される時間の前に強制された場合のみ、掃引されていないスパンがあります。

2. GCはマーク段階を実行します。

   a. a. gcphaseを（_GCoffから）_GCmarkに設定し、書き込みバリアを有効にし、ミューテーターアシストを有効にし、ルートマークジョブをキューに入れることによってマークフェーズの準備をする。すべてのPsが書き込みバリアを有効にするまで、オブジェクトはスキャンされないかもしれません。
   STWを使用して達成される。

   b. ワールドを開始する。この時点から、GCの作業はスケジューラによって起動されたマークワーカーと、アロケーションの一部として実行されたアシストによって行われます。書き込みバリアは、上書きされたポインタと新しいポインタの値の両方を、あらゆるポインタ
   が書き込まれます (詳細は mbarrier.go を参照)。新しく割り当てられたオブジェクトは、直ちに黒くマークされます。

   c. GCはルートマーキングジョブを実行する。これには、すべてのスタックのスキャン、すべてのグローバルのシェーディング、オフヒープ実行時データ構造内のすべてのヒープ・ポインタのシェーディングが含まれます。スタックのスキャンは、ゴルーチンを停止し、そのスタック上で見つかったポインタをシェーディングし、その後
   ゴルーチンを再開する。

   d. GCは、グレーオブジェクトのワークキューを排出し、各グレーオブジェクトを黒にスキャンし、オブジェクトで見つかったすべてのポインタをシェーディングする（順番にそれらのポインタをワークキューに追加することができる）。

   e. GCの仕事はローカルキャッシュに広がっているので、GCは、これ以上ルートマーキングジョブまたはグレーオブジェクトがないとき（gcMarkDoneを参照）を検出するために分散終了アルゴリズムを使用します。この時点で、GC はマーク終了に遷移します。

3. GC はマーク終了を実行します。

   a. 世界を停止する。

   b. gcphaseを_GCmarkterminationに設定し、ワーカーとアシストを無効化します。

   c. mcachesのフラッシュなどのハウスキーピングを行う。

4. GCは、掃引フェーズを実行します。

   a. gcphaseを_GCoffに設定し、sweep状態を設定し、書き込みバリアを無効にすることで、sweepフェーズの準備をします。

   b. ワールドを開始します。この時点から、新しく割り当てられたオブジェクトは白になり、必要に応じて使用前にスイープスパンを割り当てる。

   c. c. GCはバックグラウンドで、またアロケーションに対応して同時掃引を行う。以下の説明を参照してください。

5. 5. 十分な割り当てが行われたら、上記1からのシーケンスを再生します。GCの速度については後述します。

コンカレントスイープ。

掃引フェーズは、通常のプログラム実行と同時に進行します。
ヒープをスパンごとに掃引するのは、遅延(goroutineが別のスパンを必要とするとき)とバックグラウンドgoroutineでの並行(これはCPUに制約のないプログラムを助ける)の両方です。
STWマーク終了時に、すべてのスパンが "要掃引 "とマークされる。

バックグラウンドスイーパーゴルーチンは、単にスパンを1つずつ掃引します。

未掃引のスパンがあるときにOSのメモリを要求しないように、ゴルーチンが別のスパンを必要とするときは、まず掃引によってその分のメモリを回収しようとします。ゴルーチンは新しいスモール・オブジェクト・スパンを確保する必要がある場合、少なくとも1つのオブジェクトを解放するまで、同じオブジェクト・サイズのスモール・オブジェクト・スパンを掃引します。ゴルーチンがヒープからラージオブジェクトのスパンを割り当てる必要がある場合 は、ヒープに少なくともその数のページが解放されるまで、スパンを掃引します。もしゴルーチンが隣接しない1ページのスパンを2つ掃引してヒープに解放すると、新しい2ページのスパンが割り当てられますが、2ページのスパンに結合できる1ページの未掃引スパンがまだ残っている可能性があります。

掃き出されていないスパンに対して操作を続けないようにすることが重要です（GCビットマップのマークビットを破損させることになります）。GC の間、すべての mcache はセントラルキャッシュにフラッシュされるので、空です。goroutine が新しいスパンを mcache に取り込むと、それを掃引します。
ゴルーチンが明示的にオブジェクトを解放するか、ファイナライザを設定すると、そのスパンが掃引されることを保証します（掃引するか、同時掃引が終了するのを待つかのどちらか）。
ファイナライザーのゴルーチンは、すべてのスパンが掃引されたときにのみキックオフされます。
次のGCが始まるとき、まだ掃引されていないスパンをすべて掃引します（もしあれば）。

GC率です。

次のGCは、すでに使用されている量に比例して余分な量のメモリを割り当てた後です。この割合は、環境変数GOGC（デフォルトでは100）で制御されます。GOGC=100で4M使っている場合、8MになったらまたGCします（このマークはgcController.heapGoal変数で追跡されます）。これにより、GCコストは割り当てコストに線形に比例するように保たれます。GOGCを調整すると、線形定数が変わるだけです（そして、余分に使用されるメモリの量も変わります）。

オブラート

大きなオブジェクトのスキャン中の長い休止を防ぎ、並列性を高めるために、ガベージコレクタはmaxObletBytesより大きなオブジェクトのスキャンジョブを最大maxObletBytesの「オブラート」に分割しています。スキャンが大きなオブジェクトの先頭に遭遇したとき、最初のオブレットだけをスキャンし、残りのオブレットを新しいスキャンジョブとして待ち行列に並べます。
